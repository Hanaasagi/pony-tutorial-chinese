# 原语(Primitives)

__原语(primitive)__ 和　__类(class)__　相近，但是有两个重要的区别：

1. 原语没有域(field)
2. 自定义的原语只能存在一个实例

没有域就意味着原语是不可变的。单实例意味着如果您的代码调用原语类型的构造函数，总是会得到相同的结果(除了内建的 "machine word" 原语，covered below)

## 您可以使用 __原语__ 来做什么？

原语有三种主要的用途(如果您将内建的 "machine word" 算在内，就是四个)

1. 作为 "marker value"。举个例子，Pony 经常使用 __原语__ `None` 来表示值不存在的情况。

2. 作为一种枚举类型。使用由原语组成的 __共用体(union)__，您可以获得类型安全的枚举类型。关于 __union__ 我们之后会讲到。

3. 作为"函数集合"。因为原语可以有函数，您可以将函数聚集在原语类型中。您在标准库中可以见到这种用法，比如关于路径处理的函数都被放到 `Path` 原语中。

原语是十分强大，特别是作为枚举。与其他语言的枚举类型不同，Pony 的枚举中的每一个值都是一个完整的类型，这使得对枚举值附加数据和函数变得容易。

## 内建原语类型

__原语__ 关键字可以被用于引入具体的内建 “machine word” 类型。除了有相关联的值外，她们和自定义的原语相似。她们是：

* __Bool__. `true` 或 `false` 仅占一位。
* __ISize, ILong, I8, I16, I32, I64, I128__. 不同长度的有符号整数。
* __USize, ULong, U8, U16, U32, U64, U128__. 不同长度的无符号整数。
* __F32, F64__. 不同长度的浮点数。

__ISize/USize__ 对应着基本数据类型 `size_t`，长度视平台而异。__ILong/ULong__ 对应着基本类型 `long`，长度也因平台而异。Pony 提供的基本类型 `int` 是所有平台都相同的，您可以使用 __I32/U32__ 来使用。

## 原语的初始化和 finalisation(Primitive initialisation and finalisation)

原语有两种特殊函数，`_init` 和 `_final`。`_init` 在任何 actor 启动之前被调用。`_final` 在所有 actor 终止后被调用。这两种函数没有参数。不同原语的 `_init` 和 `_final` 函数的运行是有序的。

常见的使用场景是初始化和清理 C 库，避免由 actor 使用不当带来的风险。
